{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import _objectWithoutProperties from\"@babel/runtime/helpers/objectWithoutProperties\";import _defineProperty2 from\"@babel/runtime/helpers/defineProperty\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty2(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import Hammer from'@egjs/hammerjs';import findNodeHandle from\"react-native-web/dist/exports/findNodeHandle\";import{State}from\"../State\";import{EventMap}from\"./constants\";import*as NodeManager from\"./NodeManager\";var gestureInstances=0;var GestureHandler=function(){function GestureHandler(){var _this=this;_classCallCheck(this,GestureHandler);_defineProperty(this,\"handlerTag\",void 0);_defineProperty(this,\"isGestureRunning\",false);_defineProperty(this,\"view\",null);_defineProperty(this,\"hasCustomActivationCriteria\",void 0);_defineProperty(this,\"hasGestureFailed\",false);_defineProperty(this,\"hammer\",null);_defineProperty(this,\"initialRotation\",null);_defineProperty(this,\"__initialX\",void 0);_defineProperty(this,\"__initialY\",void 0);_defineProperty(this,\"config\",{});_defineProperty(this,\"previousState\",State.UNDETERMINED);_defineProperty(this,\"pendingGestures\",{});_defineProperty(this,\"oldState\",State.UNDETERMINED);_defineProperty(this,\"lastSentState\",null);_defineProperty(this,\"gestureInstance\",void 0);_defineProperty(this,\"_stillWaiting\",void 0);_defineProperty(this,\"propsRef\",void 0);_defineProperty(this,\"ref\",void 0);_defineProperty(this,\"clearSelfAsPending\",function(){if(Array.isArray(_this.config.waitFor)){for(var _iterator=_createForOfIteratorHelperLoose(_this.config.waitFor),_step;!(_step=_iterator()).done;){var gesture=_step.value;gesture.removePendingGesture(_this.id);}}});_defineProperty(this,\"destroy\",function(){_this.clearSelfAsPending();if(_this.hammer){_this.hammer.stop(false);_this.hammer.destroy();}_this.hammer=null;});_defineProperty(this,\"isPointInView\",function(_ref){var x=_ref.x,y=_ref.y;var rect=_this.view.getBoundingClientRect();var pointerInside=x>=rect.left&&x<=rect.right&&y>=rect.top&&y<=rect.bottom;return pointerInside;});_defineProperty(this,\"sendEvent\",function(nativeEvent){var _this$propsRef$curren=_this.propsRef.current,onGestureHandlerEvent=_this$propsRef$curren.onGestureHandlerEvent,onGestureHandlerStateChange=_this$propsRef$curren.onGestureHandlerStateChange;var event=_this.transformEventData(nativeEvent);invokeNullableMethod(onGestureHandlerEvent,event);if(_this.lastSentState!==event.nativeEvent.state){_this.lastSentState=event.nativeEvent.state;invokeNullableMethod(onGestureHandlerStateChange,event);}});_defineProperty(this,\"sync\",function(){var gesture=_this.hammer.get(_this.name);if(!gesture)return;var enable=function enable(recognizer,inputData){if(!_this.config.enabled){_this.isGestureRunning=false;_this.hasGestureFailed=false;return false;}if(!inputData||!recognizer.options||typeof inputData.maxPointers==='undefined'){return _this.shouldEnableGestureOnSetup;}if(_this.hasGestureFailed){return false;}if(!_this.isDiscrete){if(_this.isGestureRunning){return true;}_this._stillWaiting=_this._getPendingGestures();if(_this._stillWaiting.length){for(var _iterator2=_createForOfIteratorHelperLoose(_this._stillWaiting),_step2;!(_step2=_iterator2()).done;){var _gesture2=_step2.value;if(!_gesture2.isDiscrete&&_gesture2.isGestureRunning){_this.hasGestureFailed=true;_this.isGestureRunning=false;return false;}}return false;}}if(!_this.hasCustomActivationCriteria){return true;}var deltaRotation=_this.initialRotation==null?0:inputData.rotation-_this.initialRotation;var _this$isGestureEnable=_this.isGestureEnabledForEvent(_this.getConfig(),recognizer,_objectSpread(_objectSpread({},inputData),{},{deltaRotation:deltaRotation})),success=_this$isGestureEnable.success,failed=_this$isGestureEnable.failed;if(failed){_this.simulateCancelEvent(inputData);_this.hasGestureFailed=true;}return success;};var params=_this.getHammerConfig();gesture.set(_objectSpread(_objectSpread({},params),{},{enable:enable}));});this.gestureInstance=gestureInstances++;this.hasCustomActivationCriteria=false;}_createClass(GestureHandler,[{key:\"id\",get:function get(){return\"\".concat(this.name).concat(this.gestureInstance);}},{key:\"isDiscrete\",get:function get(){return false;}},{key:\"shouldEnableGestureOnSetup\",get:function get(){throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');}},{key:\"getConfig\",value:function getConfig(){return this.config;}},{key:\"onWaitingEnded\",value:function onWaitingEnded(_gesture){}},{key:\"removePendingGesture\",value:function removePendingGesture(id){delete this.pendingGestures[id];}},{key:\"addPendingGesture\",value:function addPendingGesture(gesture){this.pendingGestures[gesture.id]=gesture;}},{key:\"isGestureEnabledForEvent\",value:function isGestureEnabledForEvent(_config,_recognizer,_event){return{success:true};}},{key:\"NativeGestureClass\",get:function get(){throw new Error('Must override GestureHandler.NativeGestureClass');}},{key:\"updateHasCustomActivationCriteria\",value:function updateHasCustomActivationCriteria(_config){return true;}},{key:\"updateGestureConfig\",value:function updateGestureConfig(_ref2){var _ref2$enabled=_ref2.enabled,enabled=_ref2$enabled===void 0?true:_ref2$enabled,props=_objectWithoutProperties(_ref2,[\"enabled\"]);this.clearSelfAsPending();this.config=ensureConfig(_objectSpread({enabled:enabled},props));this.hasCustomActivationCriteria=this.updateHasCustomActivationCriteria(this.config);if(Array.isArray(this.config.waitFor)){for(var _iterator3=_createForOfIteratorHelperLoose(this.config.waitFor),_step3;!(_step3=_iterator3()).done;){var gesture=_step3.value;gesture.addPendingGesture(this);}}if(this.hammer){this.sync();}return this.config;}},{key:\"getState\",value:function getState(type){if(type==0){return 0;}return EventMap[type];}},{key:\"transformEventData\",value:function transformEventData(event){var eventType=event.eventType,numberOfPointers=event.maxPointers;var changedTouch=event.changedPointers[0];var pointerInside=this.isPointInView({x:changedTouch.clientX,y:changedTouch.clientY});var state=this.getState(eventType);if(state!==this.previousState){this.oldState=this.previousState;this.previousState=state;}return{nativeEvent:_objectSpread(_objectSpread({numberOfPointers:numberOfPointers,state:state,pointerInside:pointerInside},this.transformNativeEvent(event)),{},{handlerTag:this.handlerTag,target:this.ref,oldState:this.oldState}),timeStamp:Date.now()};}},{key:\"transformNativeEvent\",value:function transformNativeEvent(_event){return{};}},{key:\"cancelPendingGestures\",value:function cancelPendingGestures(event){for(var _i=0,_Object$values=Object.values(this.pendingGestures);_i<_Object$values.length;_i++){var gesture=_Object$values[_i];if(gesture&&gesture.isGestureRunning){gesture.hasGestureFailed=true;gesture.cancelEvent(event);}}}},{key:\"notifyPendingGestures\",value:function notifyPendingGestures(){for(var _i2=0,_Object$values2=Object.values(this.pendingGestures);_i2<_Object$values2.length;_i2++){var gesture=_Object$values2[_i2];if(gesture){gesture.onWaitingEnded(this);}}}},{key:\"onGestureEnded\",value:function onGestureEnded(event){this.isGestureRunning=false;this.cancelPendingGestures(event);}},{key:\"forceInvalidate\",value:function forceInvalidate(event){if(this.isGestureRunning){this.hasGestureFailed=true;this.cancelEvent(event);}}},{key:\"cancelEvent\",value:function cancelEvent(event){this.notifyPendingGestures();this.sendEvent(_objectSpread(_objectSpread({},event),{},{eventType:Hammer.INPUT_CANCEL,isFinal:true}));this.onGestureEnded(event);}},{key:\"onRawEvent\",value:function onRawEvent(_ref3){var isFirst=_ref3.isFirst;if(isFirst){this.hasGestureFailed=false;}}},{key:\"setView\",value:function setView(ref,propsRef){var _this2=this;if(ref==null){this.destroy();this.view=null;return;}this.propsRef=propsRef;this.ref=ref;this.view=findNodeHandle(ref);this.hammer=new Hammer.Manager(this.view);this.oldState=State.UNDETERMINED;this.previousState=State.UNDETERMINED;this.lastSentState=null;var NativeGestureClass=this.NativeGestureClass;var gesture=new NativeGestureClass(this.getHammerConfig());this.hammer.add(gesture);this.hammer.on('hammer.input',function(ev){if(!_this2.config.enabled){_this2.hasGestureFailed=false;_this2.isGestureRunning=false;return;}_this2.onRawEvent(ev);if(_this2.initialRotation===null&&ev.rotation!==0){_this2.initialRotation=ev.rotation;}if(ev.isFinal){setTimeout(function(){_this2.initialRotation=null;_this2.hasGestureFailed=false;});}});this.setupEvents();this.sync();}},{key:\"setupEvents\",value:function setupEvents(){var _this3=this;if(!this.isDiscrete){this.hammer.on(\"\".concat(this.name,\"start\"),function(event){return _this3.onStart(event);});this.hammer.on(\"\".concat(this.name,\"end \").concat(this.name,\"cancel\"),function(event){_this3.onGestureEnded(event);});}this.hammer.on(this.name,function(ev){return _this3.onGestureActivated(ev);});}},{key:\"onStart\",value:function onStart(_ref4){var deltaX=_ref4.deltaX,deltaY=_ref4.deltaY,rotation=_ref4.rotation;this.oldState=State.UNDETERMINED;this.previousState=State.UNDETERMINED;this.lastSentState=null;this.isGestureRunning=true;this.__initialX=deltaX;this.__initialY=deltaY;this.initialRotation=rotation;}},{key:\"onGestureActivated\",value:function onGestureActivated(ev){this.sendEvent(ev);}},{key:\"onSuccess\",value:function onSuccess(){}},{key:\"_getPendingGestures\",value:function _getPendingGestures(){if(Array.isArray(this.config.waitFor)&&this.config.waitFor.length){var stillWaiting=this.config.waitFor.filter(function(_ref5){var hasGestureFailed=_ref5.hasGestureFailed;return hasGestureFailed===false;});return stillWaiting;}return[];}},{key:\"getHammerConfig\",value:function getHammerConfig(){var pointers=this.config.minPointers===this.config.maxPointers?this.config.minPointers:0;return{pointers:pointers};}},{key:\"simulateCancelEvent\",value:function simulateCancelEvent(_inputData){}}]);return GestureHandler;}();function invokeNullableMethod(method,event){if(method){if(typeof method==='function'){method(event);}else{if('__getHandler'in method&&typeof method.__getHandler==='function'){var handler=method.__getHandler();invokeNullableMethod(handler,event);}else{if('__nodeConfig'in method){var argMapping=method.__nodeConfig.argMapping;if(Array.isArray(argMapping)){for(var index in argMapping){var _argMapping$index=_slicedToArray(argMapping[index],2),key=_argMapping$index[0],value=_argMapping$index[1];if(key in event.nativeEvent){var nativeValue=event.nativeEvent[key];if(value&&value.setValue){value.setValue(nativeValue);}else{method.__nodeConfig.argMapping[index]=[key,nativeValue];}}}}}}}}}function ensureConfig(config){var props=_objectSpread({},config);if('minDist'in config){props.minDist=config.minDist;props.minDistSq=props.minDist*props.minDist;}if('minVelocity'in config){props.minVelocity=config.minVelocity;props.minVelocitySq=props.minVelocity*props.minVelocity;}if('maxDist'in config){props.maxDist=config.maxDist;props.maxDistSq=config.maxDist*config.maxDist;}if('waitFor'in config){props.waitFor=asArray(config.waitFor).map(function(_ref6){var handlerTag=_ref6.handlerTag;return NodeManager.getHandler(handlerTag);}).filter(function(v){return v;});}else{props.waitFor=null;}var configProps=['minPointers','maxPointers','minDist','maxDist','maxDistSq','minVelocitySq','minDistSq','minVelocity','failOffsetXStart','failOffsetYStart','failOffsetXEnd','failOffsetYEnd','activeOffsetXStart','activeOffsetXEnd','activeOffsetYStart','activeOffsetYEnd'];configProps.forEach(function(prop){if(typeof props[prop]==='undefined'){props[prop]=Number.NaN;}});return props;}function asArray(value){return value==null?[]:Array.isArray(value)?value:[value];}export default GestureHandler;","map":{"version":3,"sources":["GestureHandler.ts"],"names":["gestureInstances","State","UNDETERMINED","id","isDiscrete","shouldEnableGestureOnSetup","constructor","getConfig","onWaitingEnded","removePendingGesture","addPendingGesture","gesture","isGestureEnabledForEvent","success","NativeGestureClass","updateHasCustomActivationCriteria","Array","updateGestureConfig","enabled","props","ensureConfig","y","rect","pointerInside","x","getState","type","EventMap","transformEventData","maxPointers","numberOfPointers","changedTouch","event","clientY","state","nativeEvent","handlerTag","target","oldState","timeStamp","Date","transformNativeEvent","onGestureHandlerStateChange","invokeNullableMethod","cancelPendingGestures","Object","notifyPendingGestures","onGestureEnded","forceInvalidate","cancelEvent","eventType","Hammer","isFinal","onRawEvent","isFirst","setView","ref","findNodeHandle","ev","setTimeout","setupEvents","onStart","rotation","onGestureActivated","onSuccess","_getPendingGestures","stillWaiting","hasGestureFailed","getHammerConfig","pointers","enable","recognizer","inputData","deltaRotation","failed","params","simulateCancelEvent","method","handler","argMapping","key","nativeValue","value","config","asArray","NodeManager","v","configProps","prop","Number"],"mappings":"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","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\nimport { findNodeHandle } from 'react-native';\n\nimport { State } from '../State';\nimport { EventMap } from './constants';\nimport * as NodeManager from './NodeManager';\n\n// TODO(TS) Replace with HammerInput if https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438/files is merged\nexport type HammerInputExt = Omit<HammerInput, 'destroy' | 'handler' | 'init'>;\n\nexport type Config = Partial<{\n  enabled: boolean;\n  minPointers: number;\n  maxPointers: number;\n  minDist: number;\n  minDistSq: number;\n  minVelocity: number;\n  minVelocitySq: number;\n  maxDist: number;\n  maxDistSq: number;\n  failOffsetXStart: number;\n  failOffsetYStart: number;\n  failOffsetXEnd: number;\n  failOffsetYEnd: number;\n  activeOffsetXStart: number;\n  activeOffsetXEnd: number;\n  activeOffsetYStart: number;\n  activeOffsetYEnd: number;\n  waitFor: any[] | null;\n}>;\n\ntype NativeEvent = ReturnType<GestureHandler['transformEventData']>;\n\nlet gestureInstances = 0;\n\nabstract class GestureHandler {\n  public handlerTag: any;\n  public isGestureRunning = false;\n  public view: number | null = null;\n  protected hasCustomActivationCriteria: boolean;\n  protected hasGestureFailed = false;\n  protected hammer: HammerManager | null = null;\n  protected initialRotation: number | null = null;\n  protected __initialX: any;\n  protected __initialY: any;\n  protected config: Config = {};\n  protected previousState: State = State.UNDETERMINED;\n  private pendingGestures: Record<string, this> = {};\n  private oldState: State = State.UNDETERMINED;\n  private lastSentState: State | null = null;\n  private gestureInstance: number;\n  private _stillWaiting: any;\n  private propsRef: any;\n  private ref: any;\n\n  abstract get name(): string;\n\n  get id() {\n    return `${this.name}${this.gestureInstance}`;\n  }\n\n  get isDiscrete() {\n    return false;\n  }\n\n  get shouldEnableGestureOnSetup(): boolean {\n    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\n  }\n\n  constructor() {\n    this.gestureInstance = gestureInstances++;\n    this.hasCustomActivationCriteria = false;\n  }\n\n  getConfig() {\n    return this.config;\n  }\n\n  onWaitingEnded(_gesture: this) {}\n\n  removePendingGesture(id: string) {\n    delete this.pendingGestures[id];\n  }\n\n  addPendingGesture(gesture: this) {\n    this.pendingGestures[gesture.id] = gesture;\n  }\n\n  isGestureEnabledForEvent(\n    _config: any,\n    _recognizer: any,\n    _event: any\n  ): { failed?: boolean; success?: boolean } {\n    return { success: true };\n  }\n\n  get NativeGestureClass(): RecognizerStatic {\n    throw new Error('Must override GestureHandler.NativeGestureClass');\n  }\n\n  updateHasCustomActivationCriteria(_config: Config) {\n    return true;\n  }\n\n  clearSelfAsPending = () => {\n    if (Array.isArray(this.config.waitFor)) {\n      for (const gesture of this.config.waitFor) {\n        gesture.removePendingGesture(this.id);\n      }\n    }\n  };\n\n  updateGestureConfig({ enabled = true, ...props }) {\n    this.clearSelfAsPending();\n\n    this.config = ensureConfig({ enabled, ...props });\n    this.hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(\n      this.config\n    );\n    if (Array.isArray(this.config.waitFor)) {\n      for (const gesture of this.config.waitFor) {\n        gesture.addPendingGesture(this);\n      }\n    }\n\n    if (this.hammer) {\n      this.sync();\n    }\n    return this.config;\n  }\n\n  destroy = () => {\n    this.clearSelfAsPending();\n\n    if (this.hammer) {\n      this.hammer.stop(false);\n      this.hammer.destroy();\n    }\n    this.hammer = null;\n  };\n\n  isPointInView = ({ x, y }: { x: number; y: number }) => {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n    const pointerInside =\n      x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n    return pointerInside;\n  };\n\n  getState(type: keyof typeof EventMap): State {\n    // @ts-ignore TODO(TS) check if this is needed\n    if (type == 0) {\n      return 0;\n    }\n    return EventMap[type];\n  }\n\n  transformEventData(event: HammerInputExt) {\n    const { eventType, maxPointers: numberOfPointers } = event;\n    // const direction = DirectionMap[ev.direction];\n    const changedTouch = event.changedPointers[0];\n    const pointerInside = this.isPointInView({\n      x: changedTouch.clientX,\n      y: changedTouch.clientY,\n    });\n\n    // TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.\n    const state = this.getState(eventType as 1 | 2 | 4 | 8);\n    if (state !== this.previousState) {\n      this.oldState = this.previousState;\n      this.previousState = state;\n    }\n\n    return {\n      nativeEvent: {\n        numberOfPointers,\n        state,\n        pointerInside,\n        ...this.transformNativeEvent(event),\n        // onHandlerStateChange only\n        handlerTag: this.handlerTag,\n        target: this.ref,\n        oldState: this.oldState,\n      },\n      timeStamp: Date.now(),\n    };\n  }\n\n  transformNativeEvent(_event: HammerInputExt) {\n    return {};\n  }\n\n  sendEvent = (nativeEvent: HammerInputExt) => {\n    const {\n      onGestureHandlerEvent,\n      onGestureHandlerStateChange,\n    } = this.propsRef.current;\n\n    const event = this.transformEventData(nativeEvent);\n\n    invokeNullableMethod(onGestureHandlerEvent, event);\n    if (this.lastSentState !== event.nativeEvent.state) {\n      this.lastSentState = event.nativeEvent.state as State;\n      invokeNullableMethod(onGestureHandlerStateChange, event);\n    }\n  };\n\n  cancelPendingGestures(event: HammerInputExt) {\n    for (const gesture of Object.values(this.pendingGestures)) {\n      if (gesture && gesture.isGestureRunning) {\n        gesture.hasGestureFailed = true;\n        gesture.cancelEvent(event);\n      }\n    }\n  }\n\n  notifyPendingGestures() {\n    for (const gesture of Object.values(this.pendingGestures)) {\n      if (gesture) {\n        gesture.onWaitingEnded(this);\n      }\n    }\n  }\n\n  // FIXME event is undefined in runtime when firstly invoked (see Draggable example), check other functions taking event as input\n  onGestureEnded(event: HammerInputExt) {\n    this.isGestureRunning = false;\n    this.cancelPendingGestures(event);\n  }\n\n  forceInvalidate(event: HammerInputExt) {\n    if (this.isGestureRunning) {\n      this.hasGestureFailed = true;\n      this.cancelEvent(event);\n    }\n  }\n\n  cancelEvent(event: HammerInputExt) {\n    this.notifyPendingGestures();\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_CANCEL,\n      isFinal: true,\n    });\n    this.onGestureEnded(event);\n  }\n\n  onRawEvent({ isFirst }: HammerInputExt) {\n    if (isFirst) {\n      this.hasGestureFailed = false;\n    }\n  }\n\n  setView(ref: Parameters<typeof findNodeHandle>['0'], propsRef: any) {\n    if (ref == null) {\n      this.destroy();\n      this.view = null;\n      return;\n    }\n\n    this.propsRef = propsRef;\n    this.ref = ref;\n\n    this.view = findNodeHandle(ref);\n    this.hammer = new Hammer.Manager(this.view as any);\n\n    this.oldState = State.UNDETERMINED;\n    this.previousState = State.UNDETERMINED;\n    this.lastSentState = null;\n\n    const { NativeGestureClass } = this;\n    // @ts-ignore TODO(TS)\n    const gesture = new NativeGestureClass(this.getHammerConfig());\n    this.hammer.add(gesture);\n\n    this.hammer.on('hammer.input', (ev: HammerInput) => {\n      if (!this.config.enabled) {\n        this.hasGestureFailed = false;\n        this.isGestureRunning = false;\n        return;\n      }\n\n      this.onRawEvent((ev as unknown) as HammerInputExt);\n\n      // TODO: Bacon: Check against something other than null\n      // The isFirst value is not called when the first rotation is calculated.\n      if (this.initialRotation === null && ev.rotation !== 0) {\n        this.initialRotation = ev.rotation;\n      }\n      if (ev.isFinal) {\n        // in favor of a willFail otherwise the last frame of the gesture will be captured.\n        setTimeout(() => {\n          this.initialRotation = null;\n          this.hasGestureFailed = false;\n        });\n      }\n    });\n\n    this.setupEvents();\n    this.sync();\n  }\n\n  setupEvents() {\n    // TODO(TS) Hammer types aren't exactly that what we get in runtime\n    if (!this.isDiscrete) {\n      this.hammer!.on(`${this.name}start`, (event: HammerInput) =>\n        this.onStart((event as unknown) as HammerInputExt)\n      );\n      this.hammer!.on(\n        `${this.name}end ${this.name}cancel`,\n        (event: HammerInput) => {\n          this.onGestureEnded((event as unknown) as HammerInputExt);\n        }\n      );\n    }\n    this.hammer!.on(this.name, (ev: HammerInput) =>\n      this.onGestureActivated((ev as unknown) as HammerInputExt)\n    ); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged\n  }\n\n  onStart({ deltaX, deltaY, rotation }: HammerInputExt) {\n    // Reset the state for the next gesture\n    this.oldState = State.UNDETERMINED;\n    this.previousState = State.UNDETERMINED;\n    this.lastSentState = null;\n\n    this.isGestureRunning = true;\n    this.__initialX = deltaX;\n    this.__initialY = deltaY;\n    this.initialRotation = rotation;\n  }\n\n  onGestureActivated(ev: HammerInputExt) {\n    this.sendEvent(ev);\n  }\n\n  onSuccess() {}\n\n  _getPendingGestures() {\n    if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {\n      // Get the list of gestures that this gesture is still waiting for.\n      // Use `=== false` in case a ref that isn't a gesture handler is used.\n      const stillWaiting = this.config.waitFor.filter(\n        ({ hasGestureFailed }) => hasGestureFailed === false\n      );\n      return stillWaiting;\n    }\n    return [];\n  }\n\n  getHammerConfig() {\n    const pointers =\n      this.config.minPointers === this.config.maxPointers\n        ? this.config.minPointers\n        : 0;\n    return {\n      pointers,\n    };\n  }\n\n  sync = () => {\n    const gesture = this.hammer!.get(this.name);\n    if (!gesture) return;\n\n    const enable = (recognizer: any, inputData: any) => {\n      if (!this.config.enabled) {\n        this.isGestureRunning = false;\n        this.hasGestureFailed = false;\n        return false;\n      }\n\n      // Prevent events before the system is ready.\n      if (\n        !inputData ||\n        !recognizer.options ||\n        typeof inputData.maxPointers === 'undefined'\n      ) {\n        return this.shouldEnableGestureOnSetup;\n      }\n\n      if (this.hasGestureFailed) {\n        return false;\n      }\n\n      if (!this.isDiscrete) {\n        if (this.isGestureRunning) {\n          return true;\n        }\n        // The built-in hammer.js \"waitFor\" doesn't work across multiple views.\n        // Only process if there are views to wait for.\n        this._stillWaiting = this._getPendingGestures();\n        // This gesture should continue waiting.\n        if (this._stillWaiting.length) {\n          // Check to see if one of the gestures you're waiting for has started.\n          // If it has then the gesture should fail.\n          for (const gesture of this._stillWaiting) {\n            // When the target gesture has started, this gesture must force fail.\n            if (!gesture.isDiscrete && gesture.isGestureRunning) {\n              this.hasGestureFailed = true;\n              this.isGestureRunning = false;\n              return false;\n            }\n          }\n          // This gesture shouldn't start until the others have finished.\n          return false;\n        }\n      }\n\n      // Use default behaviour\n      if (!this.hasCustomActivationCriteria) {\n        return true;\n      }\n\n      const deltaRotation =\n        this.initialRotation == null\n          ? 0\n          : inputData.rotation - this.initialRotation;\n      // @ts-ignore FIXME(TS)\n      const { success, failed } = this.isGestureEnabledForEvent(\n        this.getConfig(),\n        recognizer,\n        {\n          ...inputData,\n          deltaRotation,\n        }\n      );\n\n      if (failed) {\n        this.simulateCancelEvent(inputData);\n        this.hasGestureFailed = true;\n      }\n      return success;\n    };\n\n    const params = this.getHammerConfig();\n    // @ts-ignore FIXME(TS)\n    gesture.set({ ...params, enable });\n  };\n\n  simulateCancelEvent(_inputData: any) {}\n}\n\n// TODO(TS) investigate this method\n// Used for sending data to a callback or AnimatedEvent\nfunction invokeNullableMethod(\n  method:\n    | ((event: NativeEvent) => void)\n    | { __getHandler: () => (event: NativeEvent) => void }\n    | { __nodeConfig: { argMapping: any } },\n  event: NativeEvent\n) {\n  if (method) {\n    if (typeof method === 'function') {\n      method(event);\n    } else {\n      // For use with reanimated's AnimatedEvent\n      if (\n        '__getHandler' in method &&\n        typeof method.__getHandler === 'function'\n      ) {\n        const handler = method.__getHandler();\n        invokeNullableMethod(handler, event);\n      } else {\n        if ('__nodeConfig' in method) {\n          const { argMapping } = method.__nodeConfig;\n          if (Array.isArray(argMapping)) {\n            for (const index in argMapping) {\n              const [key, value] = argMapping[index];\n              if (key in event.nativeEvent) {\n                // @ts-ignore fix method type\n                const nativeValue = event.nativeEvent[key];\n                if (value && value.setValue) {\n                  // Reanimated API\n                  value.setValue(nativeValue);\n                } else {\n                  // RN Animated API\n                  method.__nodeConfig.argMapping[index] = [key, nativeValue];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n// Validate the props\nfunction ensureConfig(config: Config): Required<Config> {\n  const props = { ...config };\n\n  // TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)\n  if ('minDist' in config) {\n    props.minDist = config.minDist;\n    props.minDistSq = props.minDist! * props.minDist!;\n  }\n  if ('minVelocity' in config) {\n    props.minVelocity = config.minVelocity;\n    props.minVelocitySq = props.minVelocity! * props.minVelocity!;\n  }\n  if ('maxDist' in config) {\n    props.maxDist = config.maxDist;\n    props.maxDistSq = config.maxDist! * config.maxDist!;\n  }\n  if ('waitFor' in config) {\n    props.waitFor = asArray(config.waitFor)\n      .map(({ handlerTag }: { handlerTag: number }) =>\n        NodeManager.getHandler(handlerTag)\n      )\n      .filter((v) => v);\n  } else {\n    props.waitFor = null;\n  }\n\n  const configProps = [\n    'minPointers',\n    'maxPointers',\n    'minDist',\n    'maxDist',\n    'maxDistSq',\n    'minVelocitySq',\n    'minDistSq',\n    'minVelocity',\n    'failOffsetXStart',\n    'failOffsetYStart',\n    'failOffsetXEnd',\n    'failOffsetYEnd',\n    'activeOffsetXStart',\n    'activeOffsetXEnd',\n    'activeOffsetYStart',\n    'activeOffsetYEnd',\n  ] as const;\n  configProps.forEach((prop: typeof configProps[number]) => {\n    if (typeof props[prop] === 'undefined') {\n      props[prop] = Number.NaN;\n    }\n  });\n  return props as Required<Config>; // TODO(TS) how to convince TS that props are filled?\n}\n\nfunction asArray<T>(value: T | T[]) {\n  // TODO(TS) use config.waitFor type\n  return value == null ? [] : Array.isArray(value) ? value : [value];\n}\n\nexport default GestureHandler;\n"]},"metadata":{},"sourceType":"module"}