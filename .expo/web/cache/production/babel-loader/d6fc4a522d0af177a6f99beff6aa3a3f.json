{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _objectWithoutProperties from\"@babel/runtime/helpers/objectWithoutProperties\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import _regeneratorRuntime from\"@babel/runtime/regenerator\";import{CodedError}from'@unimodules/core';import*as React from'react';import StyleSheet from\"react-native-web/dist/exports/StyleSheet\";import View from\"react-native-web/dist/exports/View\";import createElement from'react-native-web/dist/exports/createElement';import{CameraType}from\"./Camera.types\";import CameraManager from\"./ExponentCameraManager.web\";import{capture}from\"./WebCameraUtils\";import{PictureSizes}from\"./WebConstants\";import{useWebCameraStream}from\"./useWebCameraStream\";import{useWebQRScanner}from\"./useWebQRScanner\";var ExponentCamera=React.forwardRef(function(_ref,ref){var _props$barCodeScanner3,_props$barCodeScanner4;var type=_ref.type,pictureSize=_ref.pictureSize,poster=_ref.poster,props=_objectWithoutProperties(_ref,[\"type\",\"pictureSize\",\"poster\"]);var video=React.useRef(null);var native=useWebCameraStream(video,type,props,{onCameraReady:function onCameraReady(){if(props.onCameraReady){props.onCameraReady();}},onMountError:props.onMountError});var isQRScannerEnabled=React.useMemo(function(){var _props$barCodeScanner,_props$barCodeScanner2;return!!((_props$barCodeScanner=props.barCodeScannerSettings)!=null&&(_props$barCodeScanner2=_props$barCodeScanner.barCodeTypes)!=null&&_props$barCodeScanner2.includes('qr')&&!!props.onBarCodeScanned);},[(_props$barCodeScanner3=props.barCodeScannerSettings)==null?void 0:_props$barCodeScanner3.barCodeTypes,props.onBarCodeScanned]);useWebQRScanner(video,{interval:(_props$barCodeScanner4=props.barCodeScannerSettings)==null?void 0:_props$barCodeScanner4.interval,isEnabled:isQRScannerEnabled,captureOptions:{scale:1,isImageMirror:native.type===CameraType.front},onScanned:function onScanned(event){if(props.onBarCodeScanned){props.onBarCodeScanned(event);}}});React.useImperativeHandle(ref,function(){return{getAvailablePictureSizes:function getAvailablePictureSizes(ratio){return _regeneratorRuntime.async(function getAvailablePictureSizes$(_context){while(1){switch(_context.prev=_context.next){case 0:return _context.abrupt(\"return\",PictureSizes);case 1:case\"end\":return _context.stop();}}},null,null,null,Promise);},takePicture:function takePicture(options){var _video$current,_video$current2;var settings;return _regeneratorRuntime.async(function takePicture$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(!(!video.current||((_video$current=video.current)==null?void 0:_video$current.readyState)!==((_video$current2=video.current)==null?void 0:_video$current2.HAVE_ENOUGH_DATA))){_context2.next=2;break;}throw new CodedError('ERR_CAMERA_NOT_READY','HTMLVideoElement does not have enough camera data to construct an image yet.');case 2:settings=native.mediaTrackSettings;if(settings){_context2.next=5;break;}throw new CodedError('ERR_CAMERA_NOT_READY','MediaStream is not ready yet.');case 5:return _context2.abrupt(\"return\",capture(video.current,settings,_objectSpread(_objectSpread({},options),{},{onPictureSaved:function onPictureSaved(picture){if(options.onPictureSaved){options.onPictureSaved(picture);}if(props.onPictureSaved){props.onPictureSaved({nativeEvent:{data:picture,id:-1}});}}})));case 6:case\"end\":return _context2.stop();}}},null,null,null,Promise);},resumePreview:function resumePreview(){return _regeneratorRuntime.async(function resumePreview$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:if(video.current){video.current.play();}case 1:case\"end\":return _context3.stop();}}},null,null,null,Promise);},pausePreview:function pausePreview(){return _regeneratorRuntime.async(function pausePreview$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(video.current){video.current.pause();}case 1:case\"end\":return _context4.stop();}}},null,null,null,Promise);}};},[native.mediaTrackSettings,props.onPictureSaved]);var isMuted=true;var style=React.useMemo(function(){var isFrontFacingCamera=native.type===CameraManager.Type.front;return[StyleSheet.absoluteFill,styles.video,{transform:isFrontFacingCamera?[{scaleX:-1}]:undefined}];},[native.type]);return React.createElement(View,{pointerEvents:\"box-none\",style:[styles.videoWrapper,props.style]},React.createElement(Video,{autoPlay:true,playsInline:true,muted:isMuted,poster:poster,pointerEvents:props.pointerEvents,ref:video,style:style}),props.children);});export default ExponentCamera;var Video=React.forwardRef(function(props,ref){return createElement('video',_objectSpread(_objectSpread({},props),{},{ref:ref}));});var styles=StyleSheet.create({videoWrapper:{flex:1,alignItems:'stretch'},video:{width:'100%',height:'100%',objectFit:'cover'}});","map":{"version":3,"sources":["../src/ExponentCamera.web.tsx"],"names":[],"mappings":"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","sourcesContent":["import { CodedError } from '@unimodules/core';\nimport * as React from 'react';\nimport { StyleProp, StyleSheet, View, ViewStyle } from 'react-native';\nimport createElement from 'react-native-web/dist/exports/createElement';\n\nimport {\n  CameraCapturedPicture,\n  CameraNativeProps,\n  CameraPictureOptions,\n  CameraType,\n} from './Camera.types';\nimport CameraManager from './ExponentCameraManager.web';\nimport { capture } from './WebCameraUtils';\nimport { PictureSizes } from './WebConstants';\nimport { useWebCameraStream } from './useWebCameraStream';\nimport { useWebQRScanner } from './useWebQRScanner';\n\nexport interface ExponentCameraRef {\n  getAvailablePictureSizes: (ratio: string) => Promise<string[]>;\n  takePicture: (options: CameraPictureOptions) => Promise<CameraCapturedPicture>;\n  resumePreview: () => Promise<void>;\n  pausePreview: () => Promise<void>;\n}\n\nconst ExponentCamera = React.forwardRef(\n  (\n    { type, pictureSize, poster, ...props }: CameraNativeProps & { children?: React.ReactNode },\n    ref: React.Ref<ExponentCameraRef>\n  ) => {\n    const video = React.useRef<HTMLVideoElement | null>(null);\n\n    const native = useWebCameraStream(video, type as CameraType, props, {\n      onCameraReady() {\n        if (props.onCameraReady) {\n          props.onCameraReady();\n        }\n      },\n      onMountError: props.onMountError,\n    });\n\n    const isQRScannerEnabled = React.useMemo<boolean>(() => {\n      return !!(\n        props.barCodeScannerSettings?.barCodeTypes?.includes('qr') && !!props.onBarCodeScanned\n      );\n    }, [props.barCodeScannerSettings?.barCodeTypes, props.onBarCodeScanned]);\n\n    useWebQRScanner(video, {\n      interval: props.barCodeScannerSettings?.interval,\n      isEnabled: isQRScannerEnabled,\n      captureOptions: { scale: 1, isImageMirror: native.type === CameraType.front },\n      onScanned(event) {\n        if (props.onBarCodeScanned) {\n          props.onBarCodeScanned(event);\n        }\n      },\n      // onError: props.onMountError,\n    });\n\n    // const [pause, setPaused]\n\n    React.useImperativeHandle(\n      ref,\n      () => ({\n        async getAvailablePictureSizes(ratio: string): Promise<string[]> {\n          return PictureSizes;\n        },\n        async takePicture(options: CameraPictureOptions): Promise<CameraCapturedPicture> {\n          if (!video.current || video.current?.readyState !== video.current?.HAVE_ENOUGH_DATA) {\n            throw new CodedError(\n              'ERR_CAMERA_NOT_READY',\n              'HTMLVideoElement does not have enough camera data to construct an image yet.'\n            );\n          }\n          const settings = native.mediaTrackSettings;\n          if (!settings) {\n            throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n          }\n\n          return capture(video.current, settings, {\n            ...options,\n            // This will always be defined, the option gets added to a queue in the upper-level. We should replace the original so it isn't called twice.\n            onPictureSaved(picture) {\n              if (options.onPictureSaved) {\n                options.onPictureSaved(picture);\n              }\n              if (props.onPictureSaved) {\n                props.onPictureSaved({ nativeEvent: { data: picture, id: -1 } });\n              }\n            },\n          });\n        },\n        async resumePreview(): Promise<void> {\n          if (video.current) {\n            video.current.play();\n          }\n        },\n        async pausePreview(): Promise<void> {\n          if (video.current) {\n            video.current.pause();\n          }\n        },\n      }),\n      [native.mediaTrackSettings, props.onPictureSaved]\n    );\n\n    // TODO(Bacon): Create a universal prop, on native the microphone is only used when recording videos.\n    // Because we don't support recording video in the browser we don't need the user to give microphone permissions.\n    const isMuted = true;\n\n    const style = React.useMemo<StyleProp<ViewStyle>>(() => {\n      const isFrontFacingCamera = native.type === CameraManager.Type.front;\n      return [\n        StyleSheet.absoluteFill,\n        styles.video,\n        {\n          // Flip the camera\n          transform: isFrontFacingCamera ? [{ scaleX: -1 }] : undefined,\n        },\n      ];\n    }, [native.type]);\n\n    return (\n      <View pointerEvents=\"box-none\" style={[styles.videoWrapper, props.style]}>\n        <Video\n          autoPlay\n          playsInline\n          muted={isMuted}\n          poster={poster}\n          // webkitPlaysinline\n          pointerEvents={props.pointerEvents}\n          ref={video}\n          style={style}\n        />\n        {props.children}\n      </View>\n    );\n  }\n);\n\nexport default ExponentCamera;\n\nconst Video = React.forwardRef(\n  (\n    props: React.ComponentProps<typeof View> & {\n      autoPlay?: boolean;\n      playsInline?: boolean;\n      muted?: boolean;\n      poster?: string;\n    },\n    ref: React.Ref<HTMLVideoElement>\n  ) => createElement('video', { ...props, ref })\n);\n\nconst styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch',\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover',\n  },\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}