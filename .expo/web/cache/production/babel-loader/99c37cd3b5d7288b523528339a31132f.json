{"ast":null,"code":"import _toConsumableArray from\"@babel/runtime/helpers/toConsumableArray\";import _defineProperty from\"@babel/runtime/helpers/defineProperty\";function _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import*as NavigationActions from\"../NavigationActions\";import*as StackActions from\"./StackActions\";import createConfigGetter from\"./createConfigGetter\";import getScreenForRouteName from\"./getScreenForRouteName\";import StateUtils from\"../StateUtils\";import validateRouteConfigMap from\"./validateRouteConfigMap\";import invariant from\"../utils/invariant\";import{generateKey}from\"./KeyGenerator\";import{createPathParser}from\"./pathUtils\";function behavesLikePushAction(action){return action.type===NavigationActions.NAVIGATE||action.type===StackActions.PUSH;}var defaultActionCreators=function defaultActionCreators(){return{};};function isResetToRootStack(action){return action.type===StackActions.RESET&&action.key===null;}export default(function(routeConfigs){var stackConfig=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};validateRouteConfigMap(routeConfigs);var childRouters={};var routeNames=Object.keys(routeConfigs);routeNames.forEach(function(routeName){var routeConfig=routeConfigs[routeName];var screen=routeConfig&&routeConfig.screen?routeConfig.screen:routeConfig;if(screen&&screen.router){childRouters[routeName]=screen.router;}else{childRouters[routeName]=null;}});var initialRouteParams=stackConfig.initialRouteParams;var getCustomActionCreators=stackConfig.getCustomActionCreators||defaultActionCreators;var initialRouteName=stackConfig.initialRouteName||routeNames[0];var initialChildRouter=childRouters[initialRouteName];function getInitialState(action){var route={};var childRouter=childRouters[action.routeName];if(behavesLikePushAction(action)&&childRouter!==undefined){var childState={};if(childRouter!==null){var childAction=action.action||NavigationActions.init({params:action.params});childState=childRouter.getStateForAction(childAction);}return{key:'StackRouterRoot',isTransitioning:false,index:0,routes:[_objectSpread(_objectSpread({params:action.params},childState),{},{key:action.key||generateKey(),routeName:action.routeName})]};}if(initialChildRouter){route=initialChildRouter.getStateForAction(NavigationActions.navigate({routeName:initialRouteName,params:initialRouteParams}));}var params=(routeConfigs[initialRouteName].params||route.params||action.params||initialRouteParams)&&_objectSpread(_objectSpread(_objectSpread(_objectSpread({},routeConfigs[initialRouteName].params||{}),route.params||{}),action.params||{}),initialRouteParams||{});var initialRouteKey=stackConfig.initialRouteKey;route=_objectSpread(_objectSpread(_objectSpread({},route),params?{params:params}:{}),{},{routeName:initialRouteName,key:action.key||initialRouteKey||generateKey()});return{key:'StackRouterRoot',isTransitioning:false,index:0,routes:[route]};}function getParamsForRouteAndAction(routeName,action){var routeConfig=routeConfigs[routeName];if(routeConfig&&routeConfig.params){return _objectSpread(_objectSpread({},routeConfig.params),action.params);}else{return action.params;}}var _createPathParser=createPathParser(childRouters,routeConfigs,stackConfig),getPathAndParamsForRoute=_createPathParser.getPathAndParamsForRoute,_getActionForPathAndParams=_createPathParser.getActionForPathAndParams;return{childRouters:childRouters,getComponentForState:function getComponentForState(state){var activeChildRoute=state.routes[state.index];var routeName=activeChildRoute.routeName;if(childRouters[routeName]){return childRouters[routeName].getComponentForState(activeChildRoute);}return getScreenForRouteName(routeConfigs,routeName);},getComponentForRouteName:function getComponentForRouteName(routeName){return getScreenForRouteName(routeConfigs,routeName);},getActionCreators:function getActionCreators(route,navStateKey){return _objectSpread(_objectSpread({},getCustomActionCreators(route,navStateKey)),{},{pop:function pop(n,params){return StackActions.pop(_objectSpread({n:n},params));},popToTop:function popToTop(params){return StackActions.popToTop(params);},push:function push(routeName,params,action){return StackActions.push({routeName:routeName,params:params,action:action});},replace:function replace(replaceWith,params,action,newKey){if(typeof replaceWith==='string'){return StackActions.replace({routeName:replaceWith,params:params,action:action,key:route.key,newKey:newKey});}invariant(typeof replaceWith==='object','Must replaceWith an object or a string');invariant(params==null,'Params must not be provided to .replace() when specifying an object');invariant(action==null,'Child action must not be provided to .replace() when specifying an object');invariant(newKey==null,'Child action must not be provided to .replace() when specifying an object');return StackActions.replace(replaceWith);},reset:function reset(actions,index){return StackActions.reset({actions:actions,index:index==null?actions.length-1:index,key:navStateKey});},dismiss:function dismiss(){return NavigationActions.back({key:navStateKey});}});},getStateForAction:function getStateForAction(action,state){if(!state){return getInitialState(action);}var activeChildRoute=state.routes[state.index];if(!isResetToRootStack(action)&&action.type!==NavigationActions.NAVIGATE){var activeChildRouter=childRouters[activeChildRoute.routeName];if(activeChildRouter){var route=activeChildRouter.getStateForAction(action,activeChildRoute);if(route!==null&&route!==activeChildRoute){return StateUtils.replaceAt(state,activeChildRoute.key,route,action.type===NavigationActions.SET_PARAMS);}}}else if(action.type===NavigationActions.NAVIGATE){for(var _iterator=_createForOfIteratorHelperLoose(state.routes.slice().reverse()),_step;!(_step=_iterator()).done;){var childRoute=_step.value;var childRouter=childRouters[childRoute.routeName];var childAction=action.routeName===childRoute.routeName&&action.action?action.action:action;if(childRouter){var nextRouteState=childRouter.getStateForAction(childAction,childRoute);if(nextRouteState===null||nextRouteState!==childRoute){var newState=StateUtils.replaceAndPrune(state,nextRouteState?nextRouteState.key:childRoute.key,nextRouteState?nextRouteState:childRoute);return _objectSpread(_objectSpread({},newState),{},{isTransitioning:state.index!==newState.index?action.immediate!==true:state.isTransitioning});}}}}if(behavesLikePushAction(action)&&childRouters[action.routeName]!==undefined){var _childRouter=childRouters[action.routeName];var _route;invariant(action.type!==StackActions.PUSH||action.key==null,'StackRouter does not support key on the push action');var lastRouteIndex=state.routes.findIndex(function(r){if(action.key){return r.key===action.key;}else{return r.routeName===action.routeName;}});if(action.type!==StackActions.PUSH&&lastRouteIndex!==-1){if(state.index===lastRouteIndex&&!action.params){return null;}var routes=state.routes.slice(0,lastRouteIndex+1);if(action.params){var _route2=state.routes[lastRouteIndex];routes[lastRouteIndex]=_objectSpread(_objectSpread({},_route2),{},{params:_objectSpread(_objectSpread({},_route2.params),action.params)});}return _objectSpread(_objectSpread({},state),{},{isTransitioning:state.index!==lastRouteIndex?action.immediate!==true:state.isTransitioning,index:lastRouteIndex,routes:routes});}if(_childRouter){var _childAction=action.action||NavigationActions.init({params:getParamsForRouteAndAction(action.routeName,action)});_route=_objectSpread(_objectSpread({params:getParamsForRouteAndAction(action.routeName,action)},_childRouter.getStateForAction(_childAction)),{},{routeName:action.routeName,key:action.key||generateKey()});}else{_route={params:getParamsForRouteAndAction(action.routeName,action),routeName:action.routeName,key:action.key||generateKey()};}return _objectSpread(_objectSpread({},StateUtils.push(state,_route)),{},{isTransitioning:action.immediate!==true});}else if(action.type===StackActions.PUSH&&childRouters[action.routeName]===undefined){return state;}if(behavesLikePushAction(action)){var childRouterNames=Object.keys(childRouters);for(var i=0;i<childRouterNames.length;i++){var childRouterName=childRouterNames[i];var _childRouter2=childRouters[childRouterName];if(_childRouter2){var initChildRoute=_childRouter2.getStateForAction(NavigationActions.init());var navigatedChildRoute=_childRouter2.getStateForAction(action,initChildRoute);var routeToPush=null;if(navigatedChildRoute===null){routeToPush=initChildRoute;}else if(navigatedChildRoute!==initChildRoute){routeToPush=navigatedChildRoute;}if(routeToPush){var _route3=_objectSpread(_objectSpread({},routeToPush),{},{routeName:childRouterName,key:action.key||generateKey()});return _objectSpread(_objectSpread({},StateUtils.push(state,_route3)),{},{isTransitioning:action.immediate!==true});}}}}if(action.type===StackActions.POP_TO_TOP){if(action.key&&state.key!==action.key){return state;}if(state.index>0){return _objectSpread(_objectSpread({},state),{},{isTransitioning:action.immediate!==true,index:0,routes:[state.routes[0]]});}return state;}if(action.type===StackActions.REPLACE){var routeIndex;if(action.key===undefined&&state.routes.length){routeIndex=state.routes.length-1;}else{routeIndex=state.routes.findIndex(function(r){return r.key===action.key;});}if(routeIndex!==-1){var _childRouter3=childRouters[action.routeName];var childState={};if(_childRouter3){var _childAction2=action.action||NavigationActions.init({params:getParamsForRouteAndAction(action.routeName,action)});childState=_childRouter3.getStateForAction(_childAction2);}var _routes=_toConsumableArray(state.routes);_routes[routeIndex]=_objectSpread(_objectSpread({params:getParamsForRouteAndAction(action.routeName,action)},childState),{},{routeName:action.routeName,key:action.newKey||generateKey()});return _objectSpread(_objectSpread({},state),{},{routes:_routes});}}if(action.type===StackActions.COMPLETE_TRANSITION&&(action.key==null||action.key===state.key)&&action.toChildKey===state.routes[state.index].key&&state.isTransitioning){return _objectSpread(_objectSpread({},state),{},{isTransitioning:false});}if(action.type===NavigationActions.SET_PARAMS){var key=action.key;var lastRoute=state.routes.find(function(route){return route.key===key;});if(lastRoute){var params=_objectSpread(_objectSpread({},lastRoute.params),action.params);var _routes2=_toConsumableArray(state.routes);_routes2[state.routes.indexOf(lastRoute)]=_objectSpread(_objectSpread({},lastRoute),{},{params:params});return _objectSpread(_objectSpread({},state),{},{routes:_routes2});}}if(action.type===StackActions.RESET){if(action.key!=null&&action.key!==state.key){return state;}var newStackActions=action.actions;return _objectSpread(_objectSpread({},state),{},{routes:newStackActions.map(function(newStackAction){var router=childRouters[newStackAction.routeName];var childState={};if(router){var _childAction3=newStackAction.action||NavigationActions.init({params:getParamsForRouteAndAction(newStackAction.routeName,newStackAction)});childState=router.getStateForAction(_childAction3);}return _objectSpread(_objectSpread({params:getParamsForRouteAndAction(newStackAction.routeName,newStackAction)},childState),{},{routeName:newStackAction.routeName,key:newStackAction.key||generateKey()});}),index:action.index});}if(action.type===NavigationActions.BACK||action.type===StackActions.POP){var _key=action.key,n=action.n,immediate=action.immediate,prune=action.prune;if(action.type===StackActions.POP&&prune===false&&_key){var index=state.routes.findIndex(function(r){return r.key===_key;});if(index>0){var count=Math.max(index-(n!==null&&n!==void 0?n:1)+1,1);var _routes3=state.routes.slice(0,count).concat(state.routes.slice(index+1));if(_routes3.length){return _objectSpread(_objectSpread({},state),{},{routes:_routes3,index:_routes3.length-1,isTransitioning:immediate!==true});}}}else{var backRouteIndex=state.index;if(action.type===StackActions.POP&&n!=null){backRouteIndex=Math.max(1,state.index-n+1);}else if(_key){var backRoute=state.routes.find(function(route){return route.key===_key;});backRouteIndex=state.routes.indexOf(backRoute);}if(backRouteIndex>0){return _objectSpread(_objectSpread({},state),{},{routes:state.routes.slice(0,backRouteIndex),index:backRouteIndex-1,isTransitioning:immediate!==true});}}}var keyIndex=action.key?StateUtils.indexOf(state,action.key):-1;for(var _iterator2=_createForOfIteratorHelperLoose(state.routes.slice().reverse()),_step2;!(_step2=_iterator2()).done;){var _childRoute=_step2.value;if(_childRoute.key===activeChildRoute.key){continue;}if(keyIndex>=0&&_childRoute.key!==action.key){continue;}var _childRouter4=childRouters[_childRoute.routeName];if(_childRouter4){var _route4=_childRouter4.getStateForAction(action,_childRoute);if(_route4===null){return state;}else if(_route4&&_route4!==_childRoute){return StateUtils.replaceAt(state,_childRoute.key,_route4,action.preserveFocus||action.type.includes('DRAWER'));}}}return state;},getPathAndParamsForState:function getPathAndParamsForState(state){var route=state.routes[state.index];return getPathAndParamsForRoute(route);},getActionForPathAndParams:function getActionForPathAndParams(path,params){return _getActionForPathAndParams(path,params);},getScreenOptions:createConfigGetter(routeConfigs,stackConfig.defaultNavigationOptions)};});","map":{"version":3,"sources":["StackRouter.js"],"names":["action","NavigationActions","StackActions","defaultActionCreators","stackConfig","validateRouteConfigMap","childRouters","routeNames","Object","routeName","routeConfig","routeConfigs","screen","initialRouteParams","getCustomActionCreators","initialRouteName","initialChildRouter","route","childRouter","behavesLikePushAction","childState","childAction","params","key","isTransitioning","index","routes","generateKey","initialRouteKey","getActionForPathAndParams","createPathParser","getComponentForState","activeChildRoute","state","getScreenForRouteName","getComponentForRouteName","getActionCreators","pop","n","popToTop","push","replace","newKey","invariant","reset","actions","navStateKey","dismiss","getStateForAction","getInitialState","isResetToRootStack","activeChildRouter","StateUtils","childRoute","nextRouteState","newState","lastRouteIndex","r","getParamsForRouteAndAction","childRouterNames","i","childRouterName","initChildRoute","navigatedChildRoute","routeToPush","routeIndex","lastRoute","newStackActions","newStackAction","router","prune","count","Math","immediate","backRouteIndex","backRoute","keyIndex","getPathAndParamsForState","getPathAndParamsForRoute","getScreenOptions","createConfigGetter"],"mappings":"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","sourcesContent":["import * as NavigationActions from '../NavigationActions';\nimport * as StackActions from './StackActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport invariant from '../utils/invariant';\nimport { generateKey } from './KeyGenerator';\nimport { createPathParser } from './pathUtils';\n\nfunction behavesLikePushAction(action) {\n  return (\n    action.type === NavigationActions.NAVIGATE ||\n    action.type === StackActions.PUSH\n  );\n}\n\nconst defaultActionCreators = () => ({});\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default (routeConfigs, stackConfig = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs);\n\n  // Loop through routes and find child routers\n  routeNames.forEach((routeName) => {\n    // We're not using `getScreenForRouteName` here to preserve the lazy loading\n    // behaviour of routes. This means that routes with child routers must be\n    // defined using a component directly or with an object with a screen prop.\n    const routeConfig = routeConfigs[routeName];\n    const screen =\n      routeConfig && routeConfig.screen ? routeConfig.screen : routeConfig;\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n\n  const { initialRouteParams } = stackConfig;\n  const getCustomActionCreators =\n    stackConfig.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n\n  const initialChildRouter = childRouters[initialRouteName];\n\n  function getInitialState(action) {\n    let route = {};\n    const childRouter = childRouters[action.routeName];\n\n    // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      let childState = {};\n      // The router is null for normal leaf routes\n      if (childRouter !== null) {\n        const childAction =\n          action.action || NavigationActions.init({ params: action.params });\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [\n          {\n            params: action.params,\n            ...childState,\n            key: action.key || generateKey(),\n            routeName: action.routeName,\n          },\n        ],\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(\n        NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: initialRouteParams,\n        })\n      );\n    }\n    const params = (routeConfigs[initialRouteName].params ||\n      route.params ||\n      action.params ||\n      initialRouteParams) && {\n      ...(routeConfigs[initialRouteName].params || {}),\n      ...(route.params || {}),\n      ...(action.params || {}),\n      ...(initialRouteParams || {}),\n    };\n    const { initialRouteKey } = stackConfig;\n    route = {\n      ...route,\n      ...(params ? { params } : {}),\n      routeName: initialRouteName,\n      key: action.key || initialRouteKey || generateKey(),\n    };\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route],\n    };\n  }\n\n  function getParamsForRouteAndAction(routeName, action) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...action.params };\n    } else {\n      return action.params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, stackConfig);\n\n  return {\n    childRouters,\n\n    getComponentForState(state) {\n      const activeChildRoute = state.routes[state.index];\n      const { routeName } = activeChildRoute;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getActionCreators(route, navStateKey) {\n      return {\n        ...getCustomActionCreators(route, navStateKey),\n        pop: (n, params) =>\n          StackActions.pop({\n            n,\n            ...params,\n          }),\n        popToTop: (params) => StackActions.popToTop(params),\n        push: (routeName, params, action) =>\n          StackActions.push({\n            routeName,\n            params,\n            action,\n          }),\n        replace: (replaceWith, params, action, newKey) => {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params,\n              action,\n              key: route.key,\n              newKey,\n            });\n          }\n          invariant(\n            typeof replaceWith === 'object',\n            'Must replaceWith an object or a string'\n          );\n          invariant(\n            params == null,\n            'Params must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            action == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            newKey == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          return StackActions.replace(replaceWith);\n        },\n        reset: (actions, index) =>\n          StackActions.reset({\n            actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey,\n          }),\n        dismiss: () =>\n          NavigationActions.back({\n            key: navStateKey,\n          }),\n      };\n    },\n\n    getStateForAction(action, state) {\n      // Set up the initial state if needed\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      const activeChildRoute = state.routes[state.index];\n\n      if (\n        !isResetToRootStack(action) &&\n        action.type !== NavigationActions.NAVIGATE\n      ) {\n        // Let the active child router handle the action\n        const activeChildRouter = childRouters[activeChildRoute.routeName];\n        if (activeChildRouter) {\n          const route = activeChildRouter.getStateForAction(\n            action,\n            activeChildRoute\n          );\n          if (route !== null && route !== activeChildRoute) {\n            return StateUtils.replaceAt(\n              state,\n              activeChildRoute.key,\n              route,\n              // the following tells replaceAt to NOT change the index to this route for the setParam action, because people don't expect param-setting actions to switch the active route\n              action.type === NavigationActions.SET_PARAMS\n            );\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        // Traverse routes from the top of the stack to the bottom, so the\n        // active route has the first opportunity, then the one before it, etc.\n\n        for (let childRoute of state.routes.slice().reverse()) {\n          let childRouter = childRouters[childRoute.routeName];\n          let childAction =\n            action.routeName === childRoute.routeName && action.action\n              ? action.action\n              : action;\n\n          if (childRouter) {\n            const nextRouteState = childRouter.getStateForAction(\n              childAction,\n              childRoute\n            );\n\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              const newState = StateUtils.replaceAndPrune(\n                state,\n                nextRouteState ? nextRouteState.key : childRoute.key,\n                nextRouteState ? nextRouteState : childRoute\n              );\n              return {\n                ...newState,\n                isTransitioning:\n                  state.index !== newState.index\n                    ? action.immediate !== true\n                    : state.isTransitioning,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle push and navigate actions. This must happen after the focused\n      // child router has had a chance to handle the action.\n      if (\n        behavesLikePushAction(action) &&\n        childRouters[action.routeName] !== undefined // undefined means it's not a childRouter or a screen\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n\n        invariant(\n          action.type !== StackActions.PUSH || action.key == null,\n          'StackRouter does not support key on the push action'\n        );\n\n        // Before pushing a new route we first try to find one in the existing route stack\n        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md\n        const lastRouteIndex = state.routes.findIndex((r) => {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        // An instance of this route exists already and we're dealing with a navigate action\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          // If index is unchanged and params are not being set, leave state identity intact\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n\n          // Remove the now unused routes at the tail of the routes array\n          const routes = state.routes.slice(0, lastRouteIndex + 1);\n\n          // Apply params if provided, otherwise leave route identity intact\n          if (action.params) {\n            const route = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = {\n              ...route,\n              params: {\n                ...route.params,\n                ...action.params,\n              },\n            };\n          }\n          // Return state with new index. Change isTransitioning only if index has changed\n          return {\n            ...state,\n            isTransitioning:\n              state.index !== lastRouteIndex\n                ? action.immediate !== true\n                : state.isTransitioning,\n            index: lastRouteIndex,\n            routes,\n          };\n        }\n\n        if (childRouter) {\n          // Delegate to the child router with the given action, or init it\n          const childAction =\n            action.action ||\n            NavigationActions.init({\n              params: getParamsForRouteAndAction(action.routeName, action),\n            });\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // note(brentvatne): does it make sense to wipe out the params\n            // here? or even to add params at all? need more info about what\n            // this solves\n            ...childRouter.getStateForAction(childAction),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        } else {\n          // Create the route from scratch\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        }\n        return {\n          ...StateUtils.push(state, route),\n          isTransitioning: action.immediate !== true,\n        };\n      } else if (\n        action.type === StackActions.PUSH &&\n        childRouters[action.routeName] === undefined\n      ) {\n        // Return the state identity to bubble the action up\n        return state;\n      }\n\n      // Handle navigation to other child routers that are not yet pushed\n      if (behavesLikePushAction(action)) {\n        const childRouterNames = Object.keys(childRouters);\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(\n              NavigationActions.init()\n            );\n            // Then check to see if the router handles our navigate action\n            const navigatedChildRoute = childRouter.getStateForAction(\n              action,\n              initChildRoute\n            );\n            let routeToPush = null;\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              const route = {\n                ...routeToPush,\n                routeName: childRouterName,\n                key: action.key || generateKey(),\n              };\n              return {\n                ...StateUtils.push(state, route),\n                isTransitioning: action.immediate !== true,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\n      if (action.type === StackActions.POP_TO_TOP) {\n        // Refuse to handle pop to top if a key is given that doesn't correspond\n        // to this router\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        // If we're already at the top, then we return the state with a new\n        // identity so that the action is handled by this router.\n        if (state.index > 0) {\n          return {\n            ...state,\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]],\n          };\n        }\n        return state;\n      }\n\n      // Handle replace action\n      if (action.type === StackActions.REPLACE) {\n        let routeIndex;\n\n        // If the key param is undefined, set the index to the last route in the stack\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex((r) => r.key === action.key);\n        }\n\n        // Only replace if the key matches one of our routes\n        if (routeIndex !== -1) {\n          const childRouter = childRouters[action.routeName];\n          let childState = {};\n          if (childRouter) {\n            const childAction =\n              action.action ||\n              NavigationActions.init({\n                params: getParamsForRouteAndAction(action.routeName, action),\n              });\n            childState = childRouter.getStateForAction(childAction);\n          }\n          const routes = [...state.routes];\n          routes[routeIndex] = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // merge the child state in this order to allow params override\n            ...childState,\n            routeName: action.routeName,\n            key: action.newKey || generateKey(),\n          };\n          return { ...state, routes };\n        }\n      }\n\n      // Update transitioning state\n      if (\n        action.type === StackActions.COMPLETE_TRANSITION &&\n        (action.key == null || action.key === state.key) &&\n        action.toChildKey === state.routes[state.index].key &&\n        state.isTransitioning\n      ) {\n        return {\n          ...state,\n          isTransitioning: false,\n        };\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find((route) => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        // Only handle reset actions that are unspecified or match this state key\n        if (action.key != null && action.key !== state.key) {\n          // Deliberately use != instead of !== so we can match null with\n          // undefined on either the state or the action\n          return state;\n        }\n        const newStackActions = action.actions;\n\n        return {\n          ...state,\n          routes: newStackActions.map((newStackAction) => {\n            const router = childRouters[newStackAction.routeName];\n\n            let childState = {};\n\n            if (router) {\n              const childAction =\n                newStackAction.action ||\n                NavigationActions.init({\n                  params: getParamsForRouteAndAction(\n                    newStackAction.routeName,\n                    newStackAction\n                  ),\n                });\n\n              childState = router.getStateForAction(childAction);\n            }\n\n            return {\n              params: getParamsForRouteAndAction(\n                newStackAction.routeName,\n                newStackAction\n              ),\n              ...childState,\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey(),\n            };\n          }),\n          index: action.index,\n        };\n      }\n\n      if (\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP\n      ) {\n        const { key, n, immediate, prune } = action;\n\n        if (action.type === StackActions.POP && prune === false && key) {\n          const index = state.routes.findIndex((r) => r.key === key);\n\n          if (index > 0) {\n            const count = Math.max(index - (n ?? 1) + 1, 1);\n            const routes = state.routes\n              .slice(0, count)\n              .concat(state.routes.slice(index + 1));\n\n            if (routes.length) {\n              return {\n                ...state,\n                routes,\n                index: routes.length - 1,\n                isTransitioning: immediate !== true,\n              };\n            }\n          }\n        } else {\n          let backRouteIndex = state.index;\n\n          if (action.type === StackActions.POP && n != null) {\n            // determine the index to go back *from*. In this case, n=1 means to go\n            // back from state.index, as if it were a normal \"BACK\" action\n            backRouteIndex = Math.max(1, state.index - n + 1);\n          } else if (key) {\n            const backRoute = state.routes.find((route) => route.key === key);\n            backRouteIndex = state.routes.indexOf(backRoute);\n          }\n\n          if (backRouteIndex > 0) {\n            return {\n              ...state,\n              routes: state.routes.slice(0, backRouteIndex),\n              index: backRouteIndex - 1,\n              isTransitioning: immediate !== true,\n            };\n          }\n        }\n      }\n\n      // By this point in the router's state handling logic, we have handled the behavior of the active route, and handled any stack actions.\n      // If we haven't returned by now, we should allow non-active child routers to handle this action, and switch to that index if the child state (route) does change..\n\n      const keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\n\n      // Traverse routes from the top of the stack to the bottom, so the\n      // active route has the first opportunity, then the one before it, etc.\n      for (let childRoute of state.routes.slice().reverse()) {\n        if (childRoute.key === activeChildRoute.key) {\n          // skip over the active child because we let it attempt to handle the action earlier\n          continue;\n        }\n        // If a key is provided and in routes state then let's use that\n        // knowledge to skip extra getStateForAction calls on other child\n        // routers\n        if (keyIndex >= 0 && childRoute.key !== action.key) {\n          continue;\n        }\n        let childRouter = childRouters[childRoute.routeName];\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n\n          if (route === null) {\n            return state;\n          } else if (route && route !== childRoute) {\n            return StateUtils.replaceAt(\n              state,\n              childRoute.key,\n              route,\n              // People don't expect these actions to switch the active route\n              // TODO: We should switch to action.preserveFocus: true for drawer in future\n              action.preserveFocus || action.type.includes('DRAWER')\n            );\n          }\n        }\n      }\n\n      return state;\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      stackConfig.defaultNavigationOptions\n    ),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}