{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import invariant from\"./utils/invariant\";var StateUtils={get:function get(state,key){return state.routes.find(function(route){return route.key===key;})||null;},indexOf:function indexOf(state,key){return state.routes.findIndex(function(route){return route.key===key;});},has:function has(state,key){return!!state.routes.some(function(route){return route.key===key;});},push:function push(state,route){invariant(StateUtils.indexOf(state,route.key)===-1,'should not push route with duplicated key %s',route.key);var routes=state.routes.slice();routes.push(route);return _objectSpread(_objectSpread({},state),{},{index:routes.length-1,routes:routes});},pop:function pop(state){if(state.index<=0){return state;}var routes=state.routes.slice(0,-1);return _objectSpread(_objectSpread({},state),{},{index:routes.length-1,routes:routes});},jumpToIndex:function jumpToIndex(state,index){if(index===state.index){return state;}invariant(!!state.routes[index],'invalid index %s to jump to',index);return _objectSpread(_objectSpread({},state),{},{index:index});},jumpTo:function jumpTo(state,key){var index=StateUtils.indexOf(state,key);invariant(index!==-1,'attempt to jump to unknown key \"%s\"',key);return StateUtils.jumpToIndex(state,index);},back:function back(state){var index=state.index-1;var route=state.routes[index];return route?StateUtils.jumpToIndex(state,index):state;},forward:function forward(state){var index=state.index+1;var route=state.routes[index];return route?StateUtils.jumpToIndex(state,index):state;},replaceAndPrune:function replaceAndPrune(state,key,route){var index=StateUtils.indexOf(state,key);var replaced=StateUtils.replaceAtIndex(state,index,route);return _objectSpread(_objectSpread({},replaced),{},{routes:replaced.routes.slice(0,index+1)});},replaceAt:function replaceAt(state,key,route){var preserveIndex=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var index=StateUtils.indexOf(state,key);var nextIndex=preserveIndex?state.index:index;var nextState=StateUtils.replaceAtIndex(state,index,route);nextState.index=nextIndex;return nextState;},replaceAtIndex:function replaceAtIndex(state,index,route){invariant(!!state.routes[index],'invalid index %s for replacing route %s',index,route.key);if(state.routes[index]===route&&index===state.index){return state;}var routes=state.routes.slice();routes[index]=route;return _objectSpread(_objectSpread({},state),{},{index:index,routes:routes});},reset:function reset(state,routes,index){invariant(routes.length&&Array.isArray(routes),'invalid routes to replace');var nextIndex=index===undefined?routes.length-1:index;if(state.routes.length===routes.length&&state.index===nextIndex){var compare=function compare(route,ii){return routes[ii]===route;};if(state.routes.every(compare)){return state;}}invariant(!!routes[nextIndex],'invalid index %s to reset',nextIndex);return _objectSpread(_objectSpread({},state),{},{index:nextIndex,routes:routes});}};export default StateUtils;","map":{"version":3,"sources":["StateUtils.js"],"names":["StateUtils","get","state","route","indexOf","has","push","invariant","routes","index","pop","jumpToIndex","jumpTo","back","forward","replaceAndPrune","replaced","replaceAt","preserveIndex","nextIndex","nextState","replaceAtIndex","reset","Array","compare"],"mappings":"+1BAAA,MAAA,CAAA,SAAA,yBAUA,GAAMA,CAAAA,UAAU,CAAG,CAIjBC,GAJiB,cAId,KAJc,CAId,GAJc,CAID,CACd,MAAOC,CAAAA,KAAK,CAALA,MAAAA,CAAAA,IAAAA,CAAmBC,SAAAA,KAAD,QAAWA,CAAAA,KAAK,CAALA,GAAAA,GAA7BD,GAAkB,EAAlBA,GAAP,IAAA,CALe,CAAA,CAYjBE,OAZiB,kBAYV,KAZU,CAYV,GAZU,CAYG,CAClB,MAAOF,CAAAA,KAAK,CAALA,MAAAA,CAAAA,SAAAA,CAAwBC,SAAAA,KAAD,QAAWA,CAAAA,KAAK,CAALA,GAAAA,GAAzC,GAA8B,EAAvBD,CAAP,CAbe,CAAA,CAoBjBG,GApBiB,cAoBd,KApBc,CAoBd,GApBc,CAoBD,CACd,MAAO,CAAC,CAACH,KAAK,CAALA,MAAAA,CAAAA,IAAAA,CAAmBC,SAAAA,KAAD,QAAWA,CAAAA,KAAK,CAALA,GAAAA,GAAtC,GAA2B,EAAlBD,CAAT,CArBe,CAAA,CA6BjBI,IA7BiB,eA6Bb,KA7Ba,CA6Bb,KA7Ba,CA6BE,CACjBC,SAAS,CACPP,UAAU,CAAVA,OAAAA,CAAAA,KAAAA,CAA0BG,KAAK,CAA/BH,GAAAA,IAAyC,CADlC,CAAA,CAAA,8CAAA,CAGPG,KAAK,CAHPI,GAAS,CAATA,CAMA,GAAMC,CAAAA,MAAM,CAAGN,KAAK,CAALA,MAAAA,CAAf,KAAeA,EAAf,CACAM,MAAM,CAANA,IAAAA,CAAAA,KAAAA,EAEA,sCAAO,KAAP,MAEEC,KAAK,CAAED,MAAM,CAANA,MAAAA,CAFF,CAAP,CAGEA,MAAAA,CAAAA,MAHF,GAvCe,CAAA,CAmDjBE,GAnDiB,cAmDd,KAnDc,CAmDN,CACT,GAAIR,KAAK,CAALA,KAAAA,EAAJ,CAAA,CAAsB,CAEpB,MAAA,CAAA,KAAA,CACD,CACD,GAAMM,CAAAA,MAAM,CAAGN,KAAK,CAALA,MAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAsB,CAArC,CAAeA,CAAf,CACA,sCAAO,KAAP,MAEEO,KAAK,CAAED,MAAM,CAANA,MAAAA,CAFF,CAAP,CAGEA,MAAAA,CAAAA,MAHF,GAzDe,CAAA,CAmEjBG,WAnEiB,sBAmEN,KAnEM,CAmEN,KAnEM,CAmES,CACxB,GAAIF,KAAK,GAAKP,KAAK,CAAnB,KAAA,CAA2B,CACzB,MAAA,CAAA,KAAA,CACD,CAEDK,SAAS,CAAC,CAAC,CAACL,KAAK,CAALA,MAAAA,CAAH,KAAGA,CAAH,CAAA,6BAAA,CAATK,KAAS,CAATA,CAEA,sCAAO,KAAP,MAEEE,KAAAA,CAAAA,KAFF,GA1Ee,CAAA,CAmFjBG,MAnFiB,iBAmFX,KAnFW,CAmFX,GAnFW,CAmFE,CACjB,GAAMH,CAAAA,KAAK,CAAGT,UAAU,CAAVA,OAAAA,CAAAA,KAAAA,CAAd,GAAcA,CAAd,CACAO,SAAS,CAACE,KAAK,GAAK,CAAX,CAAA,CAAA,qCAAA,CAATF,GAAS,CAATA,CACA,MAAOP,CAAAA,UAAU,CAAVA,WAAAA,CAAAA,KAAAA,CAAP,KAAOA,CAAP,CAtFe,CAAA,CA4FjBa,IA5FiB,eA4Fb,KA5Fa,CA4FL,CACV,GAAMJ,CAAAA,KAAK,CAAGP,KAAK,CAALA,KAAAA,CAAd,CAAA,CACA,GAAMC,CAAAA,KAAK,CAAGD,KAAK,CAALA,MAAAA,CAAd,KAAcA,CAAd,CACA,MAAOC,CAAAA,KAAK,CAAGH,UAAU,CAAVA,WAAAA,CAAAA,KAAAA,CAAH,KAAGA,CAAH,CAAZ,KAAA,CA/Fe,CAAA,CAqGjBc,OArGiB,kBAqGV,KArGU,CAqGF,CACb,GAAML,CAAAA,KAAK,CAAGP,KAAK,CAALA,KAAAA,CAAd,CAAA,CACA,GAAMC,CAAAA,KAAK,CAAGD,KAAK,CAALA,MAAAA,CAAd,KAAcA,CAAd,CACA,MAAOC,CAAAA,KAAK,CAAGH,UAAU,CAAVA,WAAAA,CAAAA,KAAAA,CAAH,KAAGA,CAAH,CAAZ,KAAA,CAxGe,CAAA,CAgHjBe,eAhHiB,0BAgHF,KAhHE,CAgHF,GAhHE,CAgHF,KAhHE,CAgHkB,CACjC,GAAMN,CAAAA,KAAK,CAAGT,UAAU,CAAVA,OAAAA,CAAAA,KAAAA,CAAd,GAAcA,CAAd,CACA,GAAMgB,CAAAA,QAAQ,CAAGhB,UAAU,CAAVA,cAAAA,CAAAA,KAAAA,CAAAA,KAAAA,CAAjB,KAAiBA,CAAjB,CAEA,sCAAO,QAAP,MAEEQ,MAAM,CAAEQ,QAAQ,CAARA,MAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAyBP,KAAK,CAA9BO,CAAAA,CAFV,GApHe,CAAA,CAiIjBC,SAjIiB,oBAiIR,KAjIQ,CAiIR,GAjIQ,CAiIR,KAjIQ,CAiImC,IAAvBC,CAAAA,aAAuB,2DAA3C,KAA2C,CAClD,GAAMT,CAAAA,KAAK,CAAGT,UAAU,CAAVA,OAAAA,CAAAA,KAAAA,CAAd,GAAcA,CAAd,CACA,GAAMmB,CAAAA,SAAS,CAAGD,aAAa,CAAGhB,KAAK,CAAR,KAAA,CAA/B,KAAA,CACA,GAAIkB,CAAAA,SAAS,CAAGpB,UAAU,CAAVA,cAAAA,CAAAA,KAAAA,CAAAA,KAAAA,CAAhB,KAAgBA,CAAhB,CACAoB,SAAS,CAATA,KAAAA,CAAAA,SAAAA,CACA,MAAA,CAAA,SAAA,CAtIe,CAAA,CA8IjBC,cA9IiB,yBA8IH,KA9IG,CA8IH,KA9IG,CA8IH,KA9IG,CA8ImB,CAClCd,SAAS,CACP,CAAC,CAACL,KAAK,CAALA,MAAAA,CADK,KACLA,CADK,CAAA,yCAAA,CAAA,KAAA,CAIPC,KAAK,CAJPI,GAAS,CAATA,CAOA,GAAIL,KAAK,CAALA,MAAAA,CAAAA,KAAAA,IAAAA,KAAAA,EAAiCO,KAAK,GAAKP,KAAK,CAApD,KAAA,CAA4D,CAC1D,MAAA,CAAA,KAAA,CACD,CAED,GAAMM,CAAAA,MAAM,CAAGN,KAAK,CAALA,MAAAA,CAAf,KAAeA,EAAf,CACAM,MAAM,CAANA,KAAM,CAANA,CAAAA,KAAAA,CAEA,sCAAO,KAAP,MAEEC,KAFK,CAELA,KAFF,CAGED,MAAAA,CAAAA,MAHF,GA7Je,CAAA,CAyKjBc,KAzKiB,gBAyKZ,KAzKY,CAyKZ,MAzKY,CAyKZ,KAzKY,CAyKW,CAC1Bf,SAAS,CACPC,MAAM,CAANA,MAAAA,EAAiBe,KAAK,CAALA,OAAAA,CADV,MACUA,CADV,CAAThB,2BAAS,CAATA,CAKA,GAAMY,CAAAA,SAAS,CAAGV,KAAK,GAALA,SAAAA,CAAsBD,MAAM,CAANA,MAAAA,CAAtBC,CAAAA,CAAlB,KAAA,CAEA,GAAIP,KAAK,CAALA,MAAAA,CAAAA,MAAAA,GAAwBM,MAAM,CAA9BN,MAAAA,EAAyCA,KAAK,CAALA,KAAAA,GAA7C,SAAA,CAAwE,CACtE,GAAMsB,CAAAA,OAAO,CAAG,QAAVA,CAAAA,OAAU,CAAA,KAAA,CAAA,EAAA,QAAehB,CAAAA,MAAM,CAANA,EAAM,CAANA,GAA/B,KAAgB,EAAhB,CACA,GAAIN,KAAK,CAALA,MAAAA,CAAAA,KAAAA,CAAJ,OAAIA,CAAJ,CAAiC,CAC/B,MAAA,CAAA,KAAA,CACD,CACF,CAEDK,SAAS,CAAC,CAAC,CAACC,MAAM,CAAT,SAAS,CAAT,CAAA,2BAAA,CAATD,SAAS,CAATA,CAEA,sCAAO,KAAP,MAEEE,KAAK,CAFA,SAAP,CAGED,MAAAA,CAAAA,MAHF,GAKD,CA/LgB,CAAnB,CAkMA,cAAA,CAAA,UAAA","sourcesContent":["import invariant from './utils/invariant';\n\n/**\n * Utilities to perform atomic operation with navigate state and routes.\n *\n * ```javascript\n * const state1 = {key: 'screen 1'};\n * const state2 = NavigationStateUtils.push(state1, {key: 'screen 2'});\n * ```\n */\nconst StateUtils = {\n  /**\n   * Gets a route by key. If the route isn't found, returns `null`.\n   */\n  get(state, key) {\n    return state.routes.find((route) => route.key === key) || null;\n  },\n\n  /**\n   * Returns the first index at which a given route's key can be found in the\n   * routes of the navigation state, or -1 if it is not present.\n   */\n  indexOf(state, key) {\n    return state.routes.findIndex((route) => route.key === key);\n  },\n\n  /**\n   * Returns `true` at which a given route's key can be found in the\n   * routes of the navigation state.\n   */\n  has(state, key) {\n    return !!state.routes.some((route) => route.key === key);\n  },\n\n  /**\n   * Pushes a new route into the navigation state.\n   * Note that this moves the index to the position to where the last route in the\n   * stack is at.\n   */\n  push(state, route) {\n    invariant(\n      StateUtils.indexOf(state, route.key) === -1,\n      'should not push route with duplicated key %s',\n      route.key\n    );\n\n    const routes = state.routes.slice();\n    routes.push(route);\n\n    return {\n      ...state,\n      index: routes.length - 1,\n      routes,\n    };\n  },\n\n  /**\n   * Pops out a route from the navigation state.\n   * Note that this moves the index to the position to where the last route in the\n   * stack is at.\n   */\n  pop(state) {\n    if (state.index <= 0) {\n      // [Note]: Over-popping does not throw error. Instead, it will be no-op.\n      return state;\n    }\n    const routes = state.routes.slice(0, -1);\n    return {\n      ...state,\n      index: routes.length - 1,\n      routes,\n    };\n  },\n\n  /**\n   * Sets the focused route of the navigation state by index.\n   */\n  jumpToIndex(state, index) {\n    if (index === state.index) {\n      return state;\n    }\n\n    invariant(!!state.routes[index], 'invalid index %s to jump to', index);\n\n    return {\n      ...state,\n      index,\n    };\n  },\n\n  /**\n   * Sets the focused route of the navigation state by key.\n   */\n  jumpTo(state, key) {\n    const index = StateUtils.indexOf(state, key);\n    invariant(index !== -1, 'attempt to jump to unknown key \"%s\"', key);\n    return StateUtils.jumpToIndex(state, index);\n  },\n\n  /**\n   * Sets the focused route to the previous route.\n   */\n  back(state) {\n    const index = state.index - 1;\n    const route = state.routes[index];\n    return route ? StateUtils.jumpToIndex(state, index) : state;\n  },\n\n  /**\n   * Sets the focused route to the next route.\n   */\n  forward(state) {\n    const index = state.index + 1;\n    const route = state.routes[index];\n    return route ? StateUtils.jumpToIndex(state, index) : state;\n  },\n\n  /**\n   * Replace a route by a key.\n   * Note that this moves the index to the position to where the new route in the\n   * stack is at and updates the routes array accordingly.\n   */\n  replaceAndPrune(state, key, route) {\n    const index = StateUtils.indexOf(state, key);\n    const replaced = StateUtils.replaceAtIndex(state, index, route);\n\n    return {\n      ...replaced,\n      routes: replaced.routes.slice(0, index + 1),\n    };\n  },\n\n  /**\n   * Replace a route by a key.\n   * Note that this moves the index to the position to where the new route in the\n   * stack is at. Does not prune the routes.\n   * If preserveIndex is true then replacing the route does not cause the index\n   * to change to the index of that route.\n   */\n  replaceAt(state, key, route, preserveIndex = false) {\n    const index = StateUtils.indexOf(state, key);\n    const nextIndex = preserveIndex ? state.index : index;\n    let nextState = StateUtils.replaceAtIndex(state, index, route);\n    nextState.index = nextIndex;\n    return nextState;\n  },\n\n  /**\n   * Replace a route by a index.\n   * Note that this moves the index to the position to where the new route in the\n   * stack is at.\n   */\n  replaceAtIndex(state, index, route) {\n    invariant(\n      !!state.routes[index],\n      'invalid index %s for replacing route %s',\n      index,\n      route.key\n    );\n\n    if (state.routes[index] === route && index === state.index) {\n      return state;\n    }\n\n    const routes = state.routes.slice();\n    routes[index] = route;\n\n    return {\n      ...state,\n      index,\n      routes,\n    };\n  },\n\n  /**\n   * Resets all routes.\n   * Note that this moves the index to the position to where the last route in the\n   * stack is at if the param `index` isn't provided.\n   */\n  reset(state, routes, index) {\n    invariant(\n      routes.length && Array.isArray(routes),\n      'invalid routes to replace'\n    );\n\n    const nextIndex = index === undefined ? routes.length - 1 : index;\n\n    if (state.routes.length === routes.length && state.index === nextIndex) {\n      const compare = (route, ii) => routes[ii] === route;\n      if (state.routes.every(compare)) {\n        return state;\n      }\n    }\n\n    invariant(!!routes[nextIndex], 'invalid index %s to reset', nextIndex);\n\n    return {\n      ...state,\n      index: nextIndex,\n      routes,\n    };\n  },\n};\n\nexport default StateUtils;\n"]},"metadata":{},"sourceType":"module"}