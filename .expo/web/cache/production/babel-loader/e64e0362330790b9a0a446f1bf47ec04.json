{"ast":null,"code":"import{PermissionStatus}from\"./Permissions.types\";export function coalesceStatuses(permissions){var statuses=Object.keys(permissions).map(function(type){return permissions[type].status;});statuses.sort(function(status1,status2){return _getStatusWeight(status1)-_getStatusWeight(status2);});return statuses[statuses.length-1];}function _getStatusWeight(status){switch(status){case PermissionStatus.GRANTED:return 0;case PermissionStatus.DENIED:return 1;case PermissionStatus.UNDETERMINED:return 2;default:return 100;}}export function coalesceExpirations(permissions){var maxExpiration=9007199254740991;var expirations=Object.keys(permissions).map(function(type){return permissions[type].expires;});expirations.sort(function(e1,e2){return(e1==null||e1==='never'?maxExpiration:e1)-(e2==null||e2==='never'?maxExpiration:e2);});return expirations[0];}export function coalesceCanAskAgain(permissions){return Object.keys(permissions).reduce(function(canAskAgain,type){return canAskAgain&&permissions[type].canAskAgain;},true);}export function coalesceGranted(permissions){return Object.keys(permissions).reduce(function(granted,type){return granted&&permissions[type].granted;},true);}","map":{"version":3,"sources":["../src/CoalescedPermissions.ts"],"names":[],"mappings":"AAAA,OAA8C,gBAA9C,2BAEA,MAAM,SAAU,CAAA,gBAAV,CAA2B,WAA3B,CAAqD,CACzD,GAAM,CAAA,QAAQ,CAAG,MAAM,CAAC,IAAP,CAAY,WAAZ,EAAyB,GAAzB,CAA6B,SAAA,IAAI,QAAI,CAAA,WAAW,CAAC,IAAD,CAAX,CAAkB,MAAtB,EAAjC,CAAjB,CACA,QAAQ,CAAC,IAAT,CAAc,SAAC,OAAD,CAAU,OAAV,QAAsB,CAAA,gBAAgB,CAAC,OAAD,CAAhB,CAA4B,gBAAgB,CAAC,OAAD,CAAlE,EAAd,EAEA,MAAO,CAAA,QAAQ,CAAC,QAAQ,CAAC,MAAT,CAAkB,CAAnB,CAAf,CACD,CAED,QAAS,CAAA,gBAAT,CAA0B,MAA1B,CAAkD,CAIhD,OAAQ,MAAR,EACE,IAAK,CAAA,gBAAgB,CAAC,OAAtB,CACE,MAAO,EAAP,CACF,IAAK,CAAA,gBAAgB,CAAC,MAAtB,CACE,MAAO,EAAP,CACF,IAAK,CAAA,gBAAgB,CAAC,YAAtB,CACE,MAAO,EAAP,CACF,QACE,MAAO,IAAP,CARJ,CAUD,CAED,MAAM,SAAU,CAAA,mBAAV,CAA8B,WAA9B,CAAwD,CAC5D,GAAM,CAAA,aAAa,CAAG,gBAAtB,CACA,GAAM,CAAA,WAAW,CAAG,MAAM,CAAC,IAAP,CAAY,WAAZ,EAAyB,GAAzB,CAA6B,SAAA,IAAI,QAAI,CAAA,WAAW,CAAC,IAAD,CAAX,CAAkB,OAAtB,EAAjC,CAApB,CACA,WAAW,CAAC,IAAZ,CACE,SAAC,EAAD,CAAK,EAAL,QACE,CAAC,EAAE,EAAI,IAAN,EAAc,EAAE,GAAK,OAArB,CAA+B,aAA/B,CAA+C,EAAhD,GACC,EAAE,EAAI,IAAN,EAAc,EAAE,GAAK,OAArB,CAA+B,aAA/B,CAA+C,EADhD,CADF,EADF,EAMA,MAAO,CAAA,WAAW,CAAC,CAAD,CAAlB,CACD,CAED,MAAM,SAAU,CAAA,mBAAV,CAA8B,WAA9B,CAAwD,CAC5D,MAAO,CAAA,MAAM,CAAC,IAAP,CAAY,WAAZ,EAAyB,MAAzB,CACL,SAAC,WAAD,CAAc,IAAd,QAAuB,CAAA,WAAW,EAAI,WAAW,CAAC,IAAD,CAAX,CAAkB,WAAxD,EADK,CAEL,IAFK,CAAP,CAID,CAED,MAAM,SAAU,CAAA,eAAV,CAA0B,WAA1B,CAAoD,CACxD,MAAO,CAAA,MAAM,CAAC,IAAP,CAAY,WAAZ,EAAyB,MAAzB,CACL,SAAC,OAAD,CAAU,IAAV,QAAmB,CAAA,OAAO,EAAI,WAAW,CAAC,IAAD,CAAX,CAAkB,OAAhD,EADK,CAEL,IAFK,CAAP,CAID","sourcesContent":["import { PermissionExpiration, PermissionMap, PermissionStatus } from './Permissions.types';\n\nexport function coalesceStatuses(permissions: PermissionMap): PermissionStatus {\n  const statuses = Object.keys(permissions).map(type => permissions[type].status);\n  statuses.sort((status1, status2) => _getStatusWeight(status1) - _getStatusWeight(status2));\n  // We choose the \"heaviest\" status with the most implications\n  return statuses[statuses.length - 1];\n}\n\nfunction _getStatusWeight(status: PermissionStatus): number {\n  // In terms of weight, we treat UNDETERMINED > DENIED > GRANTED since UNDETERMINED requires the\n  // most amount of further handling (prompting for permission and then checking that permission)\n  // and GRANTED requires the least\n  switch (status) {\n    case PermissionStatus.GRANTED:\n      return 0;\n    case PermissionStatus.DENIED:\n      return 1;\n    case PermissionStatus.UNDETERMINED:\n      return 2;\n    default:\n      return 100;\n  }\n}\n\nexport function coalesceExpirations(permissions: PermissionMap): PermissionExpiration {\n  const maxExpiration = 9007199254740991; // Number.MAX_SAFE_INTEGER\n  const expirations = Object.keys(permissions).map(type => permissions[type].expires);\n  expirations.sort(\n    (e1, e2) =>\n      (e1 == null || e1 === 'never' ? maxExpiration : e1) -\n      (e2 == null || e2 === 'never' ? maxExpiration : e2)\n  );\n  // We choose the earliest expiration\n  return expirations[0];\n}\n\nexport function coalesceCanAskAgain(permissions: PermissionMap): boolean {\n  return Object.keys(permissions).reduce<boolean>(\n    (canAskAgain, type) => canAskAgain && permissions[type].canAskAgain,\n    true\n  );\n}\n\nexport function coalesceGranted(permissions: PermissionMap): boolean {\n  return Object.keys(permissions).reduce<boolean>(\n    (granted, type) => granted && permissions[type].granted,\n    true\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}